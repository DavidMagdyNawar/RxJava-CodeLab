Index: rx-codelab/src/test/java/com/jraska/rx/codelab/Task5_IntoPractice.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- rx-codelab/src/test/java/com/jraska/rx/codelab/Task5_IntoPractice.java	(date 1490101302000)
+++ rx-codelab/src/test/java/com/jraska/rx/codelab/Task5_IntoPractice.java	(revision )
@@ -11,6 +11,8 @@
 import java.util.List;
 import java.util.UUID;
 
+import io.reactivex.schedulers.Schedulers;
+
 public class Task5_IntoPractice {
     HttpBinApi httpBinApi;
 
@@ -21,33 +23,52 @@
 
     @Test
     public void map_printRequestId() {
-        // TODO(josef): Do get request to httpbin and print out the "X-Request-Id" header UUID, there is helper method in this test for that
+        httpBinApi.getRequest()
+                .map(Task5_IntoPractice::requestId)
+                .subscribe(System.out::println);
     }
 
     @Test
     public void flatMap_performAnotherRequestAfterFirstOneArrivesBack() {
-        // TODO(josef): Once the first request emits, fire another POST request and print it out
+        httpBinApi.getRequest()
+                .flatMap(requestInfo -> httpBinApi.postRequest("Hello"))
+                .subscribe(System.out::println);
     }
 
     @Test
     public void zip_twoRequestsAndPrintThemTogether() {
-        // TODO(josef): Perform two get requests and print their ids
+        httpBinApi.getRequest()
+                .zipWith(httpBinApi.getRequest(), (info, info2) -> ids(info, info2))
+                .subscribe(System.out::println);
     }
 
     @Test
     public void zip_subscribeOn_twoRequestsInParallel() {
-        // TODO(josef): Perform two get requests and print their ids, requests shoudl run in parallel
-        // NOTE: use blockingSubscribe to stop test from finishing before the result comes back
+        httpBinApi.getRequest()
+                .subscribeOn(Schedulers.io())
+                .zipWith(httpBinApi.getRequest(), (info, info2) -> ids(info, info2))
+                .blockingSubscribe(System.out::println);
     }
 
     @Test
     public void zip_subscribeOn_twoSerialRequestsWithScheduler() {
-        // TODO(josef): Use Scheduler.single() to run GET requests in serial order, but be scheduled out of current thread
+        httpBinApi.getRequest()
+                .subscribeOn(Schedulers.single())
+                .zipWith(httpBinApi.getRequest().subscribeOn(Schedulers.single()), (info, info2) -> ids(info, info2))
+                .blockingSubscribe(System.out::println);
     }
 
     @Test
     public void subscribeOn_observeOn_twoPrintRequestsFromDifferentThread() {
-        // TODO(josef): Make the requests run in parallel, but log the emits from the same thread. You can use printWithThreadId to check that
+        httpBinApi.getRequest()
+                .subscribeOn(Schedulers.io())
+                .observeOn(Schedulers.single())
+                .doOnNext(Task5_IntoPractice::printWithThreadId)
+                .zipWith(httpBinApi.getRequest()
+                        .subscribeOn(Schedulers.io()), (info, info2) -> ids(info, info2))
+                .observeOn(Schedulers.single())
+                .doOnNext(Task5_IntoPractice::printWithThreadId)
+                .blockingSubscribe();
     }
 
     static UUID requestId(RequestInfo info) {
@@ -63,6 +84,6 @@
     }
 
     static void printWithThreadId(Object object) {
-        System.out.println(object + ", Thread id: " + Thread.currentThread().getId());
+        System.out.println(object +", Thread id: " + Thread.currentThread().getId());
     }
 }
